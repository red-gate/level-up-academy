Hard drives, modems, keyboards, printers and even network communications are just simple streams of bytes exposed through the file system.

A great example of this is that all system properties are available as a file. For example, here's how you could read the CPU info.

`cat /proc/cpuinfo`{{execute}}

`/proc/cpuinfo` isn't actually a file. The Linux kernel is exposing this information as a stream of bytes that's accessible in that way. To really illustrate that, let's look at another "file"

`cat /proc/uptime`{{execute}}

This is a stream of bytes the kernel exposes representing how long the system has been up for. Repeating this command will show increasing values as the uptime increases.

The `/dev/` space contains some other great examples.

`/dev/null` is a black hole. Anything you write to `/dev/null` will simply be discarded. You might have seen commands of the form `foo > /dev/null` - this translates to run the command `foo` and discard all output.

For reading, `/dev/random` is a never ending stream of randomly generated bytes. If you ever want to confuse someone, stick `#include </dev/random>` at the top of someone's C code.

## Sidenote - Why you (probably) don't want to use `/dev/random`...

In Unix operating systems, there's `/dev/random`, `/dev/urandom` and `/dev/arandom` - all of which return a stream of bytes. The difference is in how they gather the necessary [entropy](https://en.wikipedia.org/wiki/Entropy_(computing)).

* `/dev/random` - blocks if there is less entropy available than requested
* `/dev/urandom` - never blocks
* `/dev/arandom` - blocks after boot until there is enough entropy, then never blocks again.

Wikipedia has far more detail about [/dev/random/](https://en.wikipedia.org/wiki//dev/random)
